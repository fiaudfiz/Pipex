üß¨ COURS : Le Fork (Clonage de Processus)
1. D√©finition

L'appel syst√®me fork() est le pilier de la gestion des processus sous UNIX. Il permet √† un processus (le P√®re) de cr√©er une copie conforme de lui-m√™me (le Fils) dans un nouvel espace m√©moire.
2. Le M√©canisme du "Copy-on-Write" (COW)

Contrairement √† ce qu'on pourrait penser, fork() ne duplique pas imm√©diatement toute la RAM du p√®re (ce qui serait tr√®s lent).

    Le syst√®me partage d'abord la m√™me m√©moire physiquement.

    La copie r√©elle ne se fait que si l'un des deux processus tente de modifier une donn√©e.

    Cons√©quence : Le fork() est extr√™mement rapide.

3. Valeurs de Retour (Le s√©lecteur)

C'est le seul moment en C o√π une fonction renvoie deux valeurs diff√©rentes au m√™me instant (une dans chaque processus) :
Processus	Valeur de retour de fork()
P√®re	Le PID (Process ID) du fils (nombre > 0)
Fils	0
Erreur	-1 (si le syst√®me ne peut plus cr√©er de processus)

    Utilisation type : On utilise un if (pid == 0) pour dire au fils de faire son travail, et un else pour dire au p√®re de surveiller.

4. L'H√©ritage (Ce qui est copi√©)

Le fils h√©rite de presque tout du p√®re, mais attention aux points cl√©s pour Pipex :

    ‚úÖ Descripteurs de fichiers (FD) : Le fils a acc√®s aux m√™mes fichiers et pipes ouverts que le p√®re.

    ‚úÖ Variables : Les variables ont la m√™me valeur au moment du fork, mais deviennent ind√©pendantes ensuite.

    ‚ùå PID : Le fils a son propre identifiant unique.

5. Synchronisation et Cycle de Vie
L'attente : wait & waitpid

Un p√®re ne doit jamais laisser ses fils mourir sans s'en occuper.

    wait(int *status) : Attend qu'un de ses fils se termine.

    waitpid(pid, &status, options) : Attend un fils sp√©cifique (crucial si tu as plusieurs commandes).

    Pourquoi ? Pour r√©cup√©rer le code de sortie (exit status) et lib√©rer les ressources syst√®me.

Le Ph√©nom√®ne des Zombies üßü

Un processus Zombie est un fils qui a termin√© son ex√©cution (exit), mais dont le p√®re n'a pas encore appel√© wait().

    Il reste une "entr√©e" dans la table des processus du noyau.

    Danger : Trop de zombies peuvent saturer le syst√®me et emp√™cher la cr√©ation de nouveaux processus.

Les Orphelins

Si le p√®re meurt avant le fils, le fils devient un Orphelin. Il est alors automatiquement adopt√© par le processus init (PID 1), qui se chargera de faire le wait() √† sa place.
6. Application dans Pipex

Dans ton projet, tu utiliseras fork() pour que chaque commande (cmd1, cmd2) s'ex√©cute dans son propre espace :

    Le P√®re cr√©e le pipe.

    Le P√®re fork le premier fils (pour cmd1).

    Le P√®re fork le second fils (pour cmd2).

    Le P√®re ferme ses pipes et attend ses deux fils avec waitpid.